# 进程
通常在一个进程中可以包含若干线程，当然一个进程中至少有一个线程，不然没有存在的意义。
*注意：*
- 很多多线程是模拟出来的，真正的多线程是指多个cpu，既多核，如服务器。
如果是模拟出来的多线程，既在一个cpu的情况下，在同一时间点，cpu
只能执行一个代码，因为切换的很快，所以就有同时执行的错觉
- 线程就是独立的执行路径
- 在程序运行时，及时没有自己创建的线程，后台也会有多个线程，如主线程

自定义线程流程
1. 自定义线程类继承Thread
2. 重写run()方法，编写线程执行体
3. 创建线程对象，调用start()方法启动线程

## 实现Runnable接口
1. 第一步：定义MyRunnable类实现Runnable接口
2. 第二步：实现run方法，编写线程执行体
3. 创建线程对象，调用start方法启动线程
4. 推荐使用Runnable接口，java是单继承

**小结：**
- 继承Thread类
    - 子类继承Thread类具备多线程能力
    - 启动线程：子类对象.start();
    - 不建议使用：避免OOP单继承局限性
- 实现Runnable接口
    - 实现接口Runnable具有多线程能力
    - 启动线程：传入目标对象+Thread对象.start()
    - 避免了单继承，方便灵活，方便同一个对象被多个线程使用;
## runnable
## callable两种方式

## 静态代理模式
1. 真是对象和代理对象都要实现同一接口
2. 代理对象要代理真实角色

**静态代理的优点：**
1. 代理对象可以做很多真实对象做不了的事情
2. 真实对象就专注做自己的事情

## Lambda表达式
优点：避免内部类定义过多
其实质属于函数式编程的概念
- (params) -> expression(表达式)
- (params) -> statement[语句]
- (params) -> {statements}

比如：
```
new Thread (()-> System.out.println("多线程学习...")).start();
```
## Lambda
**总结：**

lambda表达式只能有一行代码的情况下才能简化成为一行，如果有多行，那就用代码块包裹；
前提是接口为函数式接口,函数式接口只有一个抽象方法;
多个参数也可以去掉参数类型，要去掉就都去掉;必须加上括号，

## 线程的五种状态
1. 创建状态
2. 就绪状态
3. 阻塞状态
4. 运行状态
5. 死亡状态

- 创建线程（启动线程）-》就绪状态
- 阻塞状态（阻塞解除）-》就绪状态
- 运行状态（释放CPU资源）-》就绪状态
- 就绪状态（获得CPU资源）-》运行状态
- 运行状态（等待用户输入，线程休眠等）-》阻塞
- 运行状态（线程自然执行完毕外部干涉终止线程）-》死亡状态

# 详细
- new的时候就会创建一个线程
