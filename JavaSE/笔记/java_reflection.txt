静态 VS 动态

动态语言：
    是一类在运行时可以改变其结构的语言：例如新的函数丶对象丶甚至代码可以被引进，已有的函数
    可以被删除或是其他结构上的变化。通俗来书就是在运行时代码可以根据某些条件改版自身结构；
    主要的动态语言：Object-C,C#, javascript, PHP, Python等

静态语言：
    与动态语言想对应的，运行时结构不可变的语言就是静态语言。如java丶C丶C++。
    java不是动态语言，但是java有一定的动态性。我们可以利用反射机制获得类似动态语言的特性；
    java的动态性让编程的时候更加灵活;

Reflection(反射):
    反射机制允许程序再执行期间借助于Reflection API取得任何类的内容信息，并能直接操作任意对象的
    内部属性及方法。
    class c = Class.forName("java.lang.String");
加载完类后，在退内存的方法区中就产生了一个class类型的对象(一个类只有一个class对象)，
这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面
镜子，所以我们形象的称之为：反射;
    正常方式：1.引入需要的“包类”名称-》通过new实例化-》取得实例化对象
    反射方式：1.实例化对象-》getClass()方法-》得到完整的“包类”名称

java反射优点和缺点
优点：
    可以实现动态创建对象和编译，体现出很大的灵活性
缺点：
    对性能有影响。使用反射基本上是一种解释操作，我么你可以告诉JVM，我们希望做什么并且
    它满足我们的要求，这类操作总是慢于直接执行的相同操作;
反射相关的主要API
    java.lang.Class:代表一个类
    java.lang.reflect.Method: 代表类的方法
    java.lang.reflect.Field: 代表类的成员变量
    java.lang.reflect.Constructor: 代表类的构造器

Class类
在Object类中定义了以下的方法，此方法将被所有子类继承
```
    public final native Class getClass()
```
以上的方法返回值的类型是一个Class类，此类是java反射的源头，实际上
所谓从程序的运行结果来看也很好理解，可以通过对象反射求出类中的名称；

对象照镜子后可以得到的信息：某个类的属性丶方法丶构造器，某个类到底实现哪些接口。
对于每个类而言，JRE都为其保留了一个不变的Class类型的对象.一个Class对象包含了特定某个结构

- Class（描述类的类）本身是一个类
- Class对象只能由系统建立对象
- 一个加载的类在JVM中只会有一个class实例
- Class对象对应的是一个加载到JVM中的一个.class文件
- 每个类的实例都会记得自己是由哪个Class实例所生成
- 通过Class可以完整地得到一个类中的所有被加载的结构
- Class类是Reflection的根源，针对任何你想动态加载，运行的类，唯有先获得相应的Class对象；

常用方法：
    static ClassforName(String name)
    Object newInstance()
    getName()
    Class getSuperClass()


    如何获得Class对象：
    第一种方法：(若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高)
        Class clazz = Person.class;
    第二种方法;(已知某个类的实例，调用该实例的getClass()方法获取Class对象；
        Class clazz = person.getClass();
    第三种方法;(已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，
        可能抛出ClassNotFoundException
        Class clazz = Class.forName("demo01.Student");

哪些类型可以有Class对象？
class: 外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类。
interface: 接口
[]: 数组
enum: 枚举
annotation: 注解@interface
primitive type: 基本数据类型
void

Java内存分析：
    1.堆
        - 存放new的对象和数组
        - 可以被所有的线程共享，不会存放别的对象引用
    2.

类的加载步骤：
    1.类的加载；将类的class文件读入内存，并为之创建一个java.lang.Class对象。此过程
    由类加载器完成
    步骤二：
        类的链接（Link），将类的二进制数据合并 到JRE中
    步骤三：
        类的初始化（Initialize）JVM负责对类进行初始化


加载：将class文件字节码内容加载到内存中......
链接：将java类的二进制代码合并到JVM的运行状态之中的过程;
初始化:执行类构造器<clinit>()方法的过程，初始化的时候,如果有父类，先查看父类的初始化
    虚拟机会保证一个类额<clinit>()方法在多线程环境中被正确枷锁和同步;

什么时候会发生类初始化？
类的主动引用(一定会发生类的初始化)
    当虚拟机启动，先初始化main方法所在的类
    new一个类的对象
    调用类的静态成员和静态方法；
    使用java.lang.reflect包的方法对类进行发射调用
    当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类
类的被动引用（不会发生类的初始化）
    当访问一个静态域时，只有真正声明这个域的类才会被初始化。
    通过数组定义类引用，不会触发此类的初始化
    引用常量不会触发此类的初始化；

类加载器的作用:
    源程序-》字节码.class文件-》类装载器-》字节码校验器
    -》解释器-》操作系统平台
    类缓存：标准的javaSE类加载器可以按要求查找类，但一旦某一个类
    被加载到类加载器；
类加载器分类;
    rt.jar包 是jre下lib的核心包是c++写得，类加载器类容；
    包含系统类加载器 APP
    扩展类加载器 EXT
    根类加载器
======================
创建运行时类的对象:
    Field,method,

======================
有了Class对象，能做什么？
创建类的对象：调用Class对象的newInstance()方法
    前提：
    1.类必须有一个无参数的构造器
    2.类的构造器的访问权限需要足够
    ===========================
    1.首先通过无参或者有参构造器创建一个对象
    2.第二步是，通过对象去访问方法和属性，然后进行方法的执行，操作属性，私有属性
    要进行安全检测的关闭；

=======================
性能对比分析：
普通方法快于 》 反射关闭检测快于 》 反射不关闭检测

=======================
反射操作泛型：
    - java采用泛型擦除的机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和
    免去强制类型转换问题，但是，一旦编译完成，所有的泛型有关的类型全部擦除
    - 为了通过反射操作这些类型，Java新增了ParameterizedType, GenericArrayType,
    TypeVariable 和WildcardType几种类型来代表不能被归一到Class类型但是又和
    原始类型齐名的类型;

    ParameterizedType: 表示一种参数化类型，比如Collection<String>
    GenericArrayType: 表示一种元素类型是参数化类型或者类型变量的数组类型
    TypeVariable: 是各种类型变量的公共父接口
    WildcardType:代表一种通配符类型表达式